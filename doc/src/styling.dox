/*! \page styling Styling the keyboard with CSS

\section sec0 Quick introduction to MeeGo Touch CSS
MeeGo Touch CSS mostly looks like regular CSS, though it only supports a subset of the CSS standards. Here are some things to keep in mind:
<ul>
 <li>Attributes must always be terminated by a semicolon.</li>
 <li>Each CSS class FoobarStyle usually maps to a widget named Foobar.</li>
 <li>Each theme provides constants that can be used as attribute values. Useful
  for theme-wide defaults, e.g, $COLOR_FOREGROUND. Check
  <tt>/usr/share/themes/base/meegotouch/constants.ini</tt> for more.</li>
 <li>Each CSS class comes with three inbuilt modes:
  <ul>
   <li>FoobarStyle {...}: Default mode.</li>
   <li>FoobarStyle.Landscape {...}: Overrides default when in landscape orientation.</li>
   <li>FoobarStyle.Portrait {...}: Overrides default when in portrait orientation.</li>
  </ul></li>
 <li>Attribute values are usually converted to certain Qt types internally. Some convenience units exists:
  <ul>
   <li>"mm" uses the device's resolution and DPI to convert into device-dependent pixels.</li>
   <li>"%" uses the device's display size as a base value for the percentage.</li>
  </ul></li>
 <li>MeeGo Touch splits each image into nine tiles (3x3 grid) before drawing.
  This is useful for scaling, as the four corners can be fixed whereas the
  remaining five tiles are used for scaling without introducing artefacts. The
  size of the corner tiles can be specified for each image, as a rectangle
  (left top right bottom):
  <tt>background-image: "meegotouch-keyboard-background" 15px 15px 15px 15px;</tt></li>
</ul>

Further information can be found in the <a href="http://apidocs.meego.com/git-tip/mtf/styling.html">MTF styling documentation</a>.
  
\section sec1 General appearance: MVirtualKeyboardStyle
Common settings can be changed in the MVirtualKeyboardStyle section, for example the notification font which pops up when the language or plugin
itself changed.

\section sec2 The keyboard widget: MImAbstractKeyAreaStyle
This CSS class exposes many attributes, some of them useful for debugging even.

\subsection sub0 Font settings
<ul>
 <li>font: Specifies the font for all key labels.</li>
 <li>font-color: Specifies the font color.</li>
 <li>secondary-font: Only used for keys that have a secondary label, e.g., phone number layouts.</li>
 <li>font-opacity: Specified font opacity for key in normal state. Any pressed, selected or overridden key will always use opaque font.</li>
 <li>key-pressed-font-color: The font color for pressed keys.</li>
 <i>key-selected-font-color: The font color for selected keys.</li>
 <li>key-disabled-font-color: The font color for disabled keys.</li>
 <li>key-highlighted-font-color: The font color for highlighted keys. Does not apply to disabled keys.</li>
</ul>

\subsection sub1 Graphical assets
<ul>
 <li>background-image: Specified the background of the keyboard. Can be translucent.
 <li>key-background: Specifies the key's default background, i.e., when not pressed. Key backgrounds are supposed to be opaque.</li>
 <li>key-background-disabled: Specifies the key's background when key is disabled.</li>
 <li>key-background-pressed: Specifies the key's background when key is pressed.</li>
 <li>key-background-seleced: Specifies the key's background when key is selected (e.g., caps-lock state for shift key).</li>
 <li>key-background-pressed-seleced: Specifies the key's background when key is pressed whilst being selected.</li>
 <li>The other attributes are the cross product of {key-background} x
{higlighted, special, special-highlighted, deadkey, deadkey-highlighted} x {,
pressed, disabled, selected}. Keys can be highlighted dynamically (determined
by application), whereas special and deadkey are specified as the key's style
attribute in the XML layout files.</li>
 <li>key-{backspace, menu, enter, shift, tab}-icon-id: Specifies icon for backspace, menu, enter, shift or tab key.</li>
 <li>key-{backspace, menu, enter, shift, tab}-icon-id-rtl: Specifies right-to-left icon variant for backspace, menu, enter, shift or tab key.</li>
 <li>key-{backspace, menu, enter, shift, tab}-icon-size: Specifies the icon size for backspace, menu, enter, shift or tab key.</li>
 <li>key-shift-uppercase-icon-id: Uppercase variant for shift key.</li>
 <li>key-{backspace, menu, enter, shift, shift-uppercase, tab}-compact-icon-size: Size of compact icon.</li>
 <li>key-{backspace, menu, enter, shift, shift-uppercase, tab}-compact-icon-id: Id of compact icon. See required-key-icon-margins for details.</li>
 <li>key-{backspace, menu, enter, shift, shift-uppercase, tab}-compact-icon-id-rtl: Id of compact icon version (rtl).</li>
</ul>

\subsection sub2 Behaviour
<ul>
 <li>long-press-timeout: How long to press key (in ms) to be recognized as long-press.</li>
 <li>idle-vkb-timeout: How long (in ms) does it take for the keyboard to return into
idle state, after switching into a so-called speed-typing mode (triggered by
pressing two keys in quick succession, for example}. Measured from the point of
last key {press, move, release} event. Certain gestures are only available in
idle state.</li>
 <li>flick-gesture-timeout: How long (in ms) should the keyboard try to recognize a gesture as a flick gesture, measured from gesture start.</li>
 <li>flick-gesture-threshold-ratio: Distance in [0, 1] of keyboard size
(vertically and horizontally) that a finger needs to move to trigger this
gesture.</li>
 <li>touchpoint-vertical-offset: Subtracted from y coordinate of a touchpoint, to be adjusted depending on display accuracy (there is usually a human bias to hit lower than what is assumed, due to the aiming with finger tips).</li>
 <li>enable-overlay-mode: In overlay mode, reactive area of first/last row spawns to top/bottom of display. Does not affect key geometry.</li>
 <li>commit-previous-key-on-press: Controls whether a new key press commits (and releases) a previous held down key. For best usability, this should be enabled for all basic key areas.</li>
</ul>

\subsection sub3 Key geometry
Each key has an area - specified by width and row height (all keys in one row share same height but can have different width) - and margins (left, top, right, bottom). Area and margins define the reactive area (all touch events inside a reactive area are handled by that key) and the spacing between keys. The one exception are the paddings of the keyboard widget, which override the key margins like so:
<ul>
 <li>padding-left: Overrides key-margin-left for left-most keys, in each row.</li>
 <li>padding-top: Overrides key-margin-top for top row.</li>
 <li>padding-right: Overrides key-margin-right for right-most keys, in each row.</li>
 <li>padding-bottom: Overrides key-margin-bottom for bottom row.</li>
</ul>

The other key geometry attributes are as follows:
<ul>
 <li>required-key-icon-margins: The required (total) horizontal and vertical margins available around the icon of a key.
If the actual margins available in a key is less than this, the compact icon is used instead of the normal one.
This allows two set of graphical assets to be used for icons to better fit varying key sizes. There is no
further fallback or scaling if the compact icon also turns out to be too big.</li>
 <li>use-fixed-key-width: Can be true or false and determines whether keys are
auto-sized regarding their relative key width in order to consume the full row
width. If true, no auto-sizing takes place and the key-width-{small, medium,
large, x-large, xx-large, stretched}-fixed variants are used. For the
auto-sizing, the row with the most keys is used to calculate a key width unit.
All other key width values (but not the fixed ones) are relative to that key
width unit.</li>
 <li>key-width-small: Percentage between [0, 1] for <key width="small" ...></li>
 <li>key-width-medium: Percentage between [0, 1] for <key width="medim" ...></li>
 <li>key-width-large: Percentage between [0, 1] for <key width="large" ...></li>
 <li>key-width-x-large: Percentage between [0, 1] for <key width="x-large" ...></li>
 <li>key-width-xx-large: Percentage between [0, 1] for <key width="xx-large" ...></li>
 <li>key-width-stretched: Percentage between [0, 1] for <key width="stretched" ...> A stretched key would usually consume all remaining width in a row, so this attribute is currently useless.</li>
 <li>key-margin-left: Left margin of key.</li>
 <li>key-margin-top: Top margin of key.</li>
 <li>key-margin-right: Right margin of key.</li>
 <li>key-margin-bottom: Bottom margin of key.</li>
 <li>padding-left: Left padding of keyboard widget.</li>
 <li>padding-top: Top padding of keyboard widget.</li>
 <li>padding-right: Right padding of keyboard widget.</li>
 <li>padding-bottom: Bottom padding of keyboard widget.</li>
 <li>size: Specifies size of keyboard width (w, h). -1 allows to take as much space as needed to fit all keys into it.</li>
</ul>

\subsection sub4 Miscelleanous
<ul>
 <li>sync-style-mode-with-key-count: A boolean. If true, special style modes
that are based on the amount of keys in a given layout can be used. Discouraged
for normal use but might be necessary for pixel-perfectness. The special style
modes can be triggered by layouts containing 10-15 or 30-45 keys. The special
style modes can be accessed like so:
<tt>MImAbstractKeyAreaStyle.Landscape:keys36 {...}</tt>. In this case, a layout
with 36 keys, when in landscape mode, would use overrides from this section on
top of the regular landscape overrides for the default mode.</li>
</ul>

\subsection sub5 Debugging
The following attributes are useful for debugging only. Some of them draw extra information on the screen, whereas others dump the information into logfiles.

<ul>
 <li>draw-button-bounding-rects: Boolean. Whether to draw the key's bounding rectangle (key area together with key margins). Also displays size.</li>
 <li>draw-button-rects: Boolean. Whether to draw the key's area. Also displays size.</li>
 <li>draw-reactive-areas: Boolean. Whether to draw reactive areas of keys. Usually similar to bounding rectangles.</li>
 <li>debug-touch-points: Boolean. If true, dumps all touchpoint information into a logfile, found at <tt>$HOME/.meego-im/&lt;PID&gt;-touchpoints.csv</tt>
The format is a CSV file, with the following columns:
  <ul>
  <li>time (sec.msec): Timestamp.</li>
  <li>tp_id: Touch point id (useful if multiple touchpoints are active).</li>
  <li>tp_state: One of pressed, moved, released.</li>
  <li>start_x, start_y: Start position of touchpoint.</li>
  <li>last_x, last_y: Last seen position of touchpoint.</li>
  <li>current_x, current_y: Current position of touchpoint. current_i-1 = last_i.</li>
  <li>center_x, center_y: Center of touched key, if any.</li>
  <li>delta_x, delta_y: How much does the current touchpoint deviate from key center.</li>
  <li>label: Label of currently touched key, if any.</li>
  <li>label_last: Label of last touched key, if any (with respect to touch trace).</li>
  <li>br_x, br_y, br_w, br_h: Bounding rectangle of current key (key area + margins)</li>
 </ul></li>
</ul> 
*/
